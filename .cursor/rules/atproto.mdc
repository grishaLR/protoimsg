---
description: "ATProto protocol standards: Lexicon schemas, Jetstream, record ownership, federation safety"
alwaysApply: false
globs: ["packages/lexicon/**", "packages/server/src/firehose/**", "packages/server/src/auth/**", "packages/web/src/lib/atproto*"]
---

# ATProto & Lexicon — Protocol Standards

You are an ATProto protocol engineer. Every decision must be federation-safe and forward-compatible.

## Record Ownership

Records live in *user* repos, not on our server. The server indexes them but never owns them. Users can move their data to any app that implements this Lexicon. Respect this — never store authoritative data server-side that should be a user record.

Public ATProto records: rooms, messages, community lists, presence, bans, roles, polls, votes, allowlists. Private server-only data: DMs (7-day retention), sessions, presence state (in-memory).

## Schema Evolution

All Zod validation schemas MUST use `.passthrough()` — unknown fields from future schema versions must survive, not be stripped. `knownValues` are open sets in ATProto — validate with `z.string()`, never `z.enum()`. A new value arriving should not break your handler.

After modifying any schema in `packages/lexicon/schemas/`, run `pnpm --filter @protoimsg/lexicon codegen` to regenerate types. CI validates this with `pnpm validate:lexicon`.

## Jetstream Consumer

Filter with `wantedCollections=app.protoimsg.chat.*` query param — never subscribe to the full firehose. Handle three event kinds: `commit` (record CRUD), `identity` (handle changes), `account` (deactivation). Save cursor every 100 events for crash recovery. Jetstream retains 72h, so you have time to catch up.

Every handler must be idempotent (upsert pattern). Events can replay on restart.

## TID Generation

Record keys use TIDs — 13-character base32-sortable identifiers. Top 53 bits = microsecond timestamp, bottom 10 = clock counter. Use the existing `generateTid()` helper. Never use UUIDs or random strings for record keys.

## Rich Text Facets

Facets use UTF-8 *byte* offsets (`byteStart`/`byteEnd`), not character indices. Always convert via `TextEncoder`/`TextDecoder`. Merge two facet sources: markdown parsing (bold, italic, code) + `RichTextAPI.detectFacets(agent)` (mentions, links, tags). Support both `app.protoimsg.chat.message#mention` and `app.bsky.richtext.facet#mention` — be format-agnostic.

## AT-URI Format

`at://{did}/{collection}/{rkey}`. Parse by splitting on `/`. Validate DIDs with `did:[a-z0-9]+:[a-zA-Z0-9._:%-]+` (supports did:plc, did:web, did:key).

## Auth Proof

Challenge-response via PDS record: client writes a nonce to `app.protoimsg.chat.authVerify` in their repo, server fetches it from their PDS to prove write access. This is unauthenticated public PDS read — no OAuth needed for verification. Resolve PDS endpoint from DID document (plc.directory for did:plc, .well-known/did.json for did:web).

## Presence Visibility Model

`visibleTo` controls who sees your real status:
- `everyone` → all community members (fast path: skip DB, just check blocks)
- `community` → only users in your community list (requires DB lookup per watcher)
- `inner-circle` → only `isInnerCircle: true` group members
- `no-one` → appear offline to everyone

Block checks are unidirectional: if A blocks B, B sees A as offline. Always check.
