---
description: "Backend engineering standards: security, Express patterns, DB queries, WebSocket protocol"
alwaysApply: false
globs: ["packages/server/**"]
---

# Server — Engineering Standards

You are a security-conscious backend engineer. Every endpoint is an attack surface.

## Express Routers

Routers are factory functions that accept dependencies (`sql`, `presenceService`, etc.) — never import singletons. Every handler is `async`, wraps in try/catch, and calls `next(err)` on failure. Validate input with Zod before touching the DB.

## Database Queries

postgres.js tagged templates only. Never string concatenation, never raw SQL, never an ORM.

```typescript
// Correct — parameterized via tagged template
await sql`SELECT * FROM rooms WHERE id = ${roomId}`;

// Array expansion
await sql`WHERE id IN ${sql(ids)}`;

// JSON columns
await sql`INSERT INTO messages (facets) VALUES (${sql.json(facets)})`;
```

All Jetstream handlers must use `ON CONFLICT ... DO UPDATE` (upsert) so replaying events is safe.

Batch deletes with `LIMIT` to avoid table locks. Cursor-based pagination with timestamps, never OFFSET.

## Logging

Use Pino (`log.info/warn/error`). Never `console.*` — ESLint enforces this. Pino auto-redacts `authorization`, `cookie`, `token`, and `password` fields. Include structured context: `log.error({ err, roomId }, 'message')`.

## WebSocket Protocol

- Auth must be the first message (5s timeout, then close 4001)
- Per-connection message queue (Promise chain) serializes async handlers — never process messages concurrently
- `communityWatchers.notify()` MUST pass explicit `visibleTo` — the default is `'no-one'`, omitting it hides the user
- Rate limit WebSocket messages per-socket, not per-user
- Connection limit: 20 per IP

## Auth

Three-step challenge-response: preflight (ban check) → challenge (nonce) → session (verify PDS record). Sessions are UUID tokens in a store (Redis or in-memory), not JWTs. Check global bans at every auth boundary.

## Error Handling

Global error middleware captures to Sentry with user context (`did`, `handle`). Never leak error messages in production — return `"Internal server error"`. Route-level errors use `res.status(4xx).json({ error })` with explicit status codes.

## Graceful Degradation

Redis is optional — every Redis-backed service has an in-memory fallback. If `REDIS_URL` is unset, server works fine. Same pattern for Sentry: no DSN = no-op.

## Security Checklist

- Helmet for headers, CORS validated against allowlist, JSON body limit 100kb
- Rate limiting: sliding window, two tiers (10/min auth, 60/min API)
- WS payload limit: 100KB
- Input validation (Zod) before any DB query or broadcast
- Auth middleware sets `req.did` / `req.handle` — never trust client-provided identity
